<book>
  <bookinfo>
    <title>Programming Reference For The OFX Image Effect Plug-in API, 1.0</title>

    <author>
      <firstname>Bruno</firstname>
      
      <surname>Nicoletti</surname>
    </author>

    <copyright>
      <year>2005</year>

      <holder>Bruno Nicoletti</holder>
    </copyright>

    <releaseinfo>Document version 0.3</releaseinfo>
  </bookinfo>

  <preface>
    <title>Foreword</title>
    <para>UNFINISHED</para>
  </preface>
  
  <chapter><title>Structure of The OFX and the Image Effect API</title>
    <section> <title>The Structure Of The Generic OFX API</title>
      <para>
	OFX is actually several things. At its the base it is a generic plug-in architecture with which can be used to implement a variety of
	plug-in APIs. The first such API to be implemented on the core architecture is the OFX Image Effect Plug-in API.
      </para>
      
      <para>
	It is all specified using the 'C' programming language. C and C++ are the languages mainly used to write visual effects applications (the initial target for OFX plug-in APIs) and have a very wide adoption across most operating systems with many available compilers. By making the API C, rather than C++, you remove the whole set of problems around C++ symbol mangling between the host and plug-in.
      </para>

      <para>
	APIs are defined inOFX by only a set of C header files and associated documentation. There are no binary libraries for a plug-in or host to link against.
      </para>

      <para>
	Hosts rely on two symbols within a plug-in, all other communication is boot strapped from those two symbols. The plug-in has no symbolic dependancies from the host. This minimal symbolic dependancy allows for run-time determination of what features to provide over the API, making implementation much more flexible and less prone to backwards compatibility problems.
      </para>
      
      <para>
	Plug-ins, via the two exposed symbols, indicate the API they implement, the version of the API, their name, their version and their main entry point.
      </para>

      <para>
	A host communicates with a plug-in via sending 'actions' to the plug-in's main entry function. Actions are C strings that indicate the specific operation to be carried out. They are associated with sets of properties which allows the main entry function to behave as a generic function.
      </para>

      <para>
	A plug-in communicates with a host by using sets of functions pointers given it by the host. These sets of function pointers, known as 'suites', are named via a C string and a version number. They are returned on request from the host as pointers within a C struct.
      </para>

      <para>
	Properties are typed value/name pairs that exist on the various OFX objects and are action rguments values to the plug-in's main entry point. They are how a plug-in and host pass individual values back and forth to each other. The property suite, defined inside <filename class="headerfile">ofxProperty.h</filename> is used to do this.
      </para>
    </section>

    <section>
      <title>OFX APIs</title>
      <para>
	An OFX plug-in API is a named set of actions, properties and suites to perform some specific set of tasks. The first such API that has been defined on
	the OFX core is the OFX Image Effect API. The set of actions, properties and suites that constitute the API makes up the major part of this document.
      </para>
      
      <para>
	Various suites and actions have been defined for the OFX image effect API, however many are actually quite generic and could be 
	reused by other APIs. 
	The property suite definitely has to be used by all other APIs, while the memory allocation suite, the parameter
	suite and several others would propably be useful for all other APIs. For example the paramter suite could be re-used to specify user
	visible parameters to the other APIs.
      </para>
      
      <para>
	Several types are common to all OFX APIs, and as such are defined in <filename class="headerfile">ofxCore.h</filename>. Most objects passed back to
	a plug-in are generally specified by blind data handles, for example the <code>OfxPropertySetHandle</code>. This allows for strong typing on functions
	but allows the implementation of the object to be hidden from the plug-in.
	<itemizedlist>
	  <listitem>
	    <emphasis>OfxStatus</emphasis> - used to define a set of status codes indicating the sucess or failure of an action or suite function,
	  </listitem>
	  <listitem>
	    <emphasis>OfxPropertySetHandle</emphasis> - a blind handle to a set of properties on an object or action,
	  </listitem>
	  <listitem>
	    <emphasis>OfxHost</emphasis> - a C struct that is used by a plug-in to get access to suites from a host and properties about the host,
	  </listitem>
	  <listitem>
	    <emphasis>OfxPluginEntryPoint</emphasis> - a typedef for functions used as main entry points for a plug-in (and several other objects),
	  </listitem>
	  <listitem>
	    <emphasis>OfxPlugin</emphasis> - a C struct that a plug-in fills in to describe itself to a host.
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	Several general assumptions have been made about how hosts and plug-ins communicate, which specific APIs <emphasis>are</emphasis> allowed to break.
	The main is the distinction between...
	<itemizedlist>
	  <listitem>
	    <emphasis>descriptors</emphasis> - which hosts and plug-ins use to define the general behaviour of an object, e.g. the object used to specify what bit depths an Image Effect Plug-in is willing to accept,
	  </listitem>
	  <listitem>
	    <emphasis>instances</emphasis> - which hosts and plug-ins use to control the behaviour of a specific 'live' object.
	  </listitem>
	</itemizedlist>
	In most APIs descriptors are typically passed from a host to a plug-in during the <link linkEnd="kOfxActionDescribe">kOfxActionDescribe</link> action, whilst all other actions are passed and instance, e.g: the object passed to the <link linkEnd="kOfxActionCreateInstance">kOfxActionCreateInstance</link> action.
      </para>
      
    </section>

    <section>
      <title>The OFX Image Effect API.</title>
      <para>
	The OFX Image Effect Plug-in API is a designed for image effect plug-ins for 2D visual effects. This includes such host applications as compositors,
	editors, rotoscoping tools and colour grading sytems.
      </para>
      
      <para>
	At heart the image effect API allows a host to send a plug-in a set of images, state the value of a set of parameters and get a resulting back. 
	However how it does this is somewhat complicated, as the plug-in and host have to negotiate what kind of images are handled, how they
	can be processed and much more.
      </para>

    </section>
  </chapter>
  
  <chapter>
    <title>The Generic Core API</title>
    <section>
      This chapter describes how plug-ins are distributed and the core API for loading and identifying image effect plug-ins, and the methods of communications between plug-and host.
    </section>
    
    &ofxPackaging;


    <section id="Core OFX include files">
      <title>OFX Include Files</title>
      <para>
	The 'C' include files that define an OFX API are all that are needed by a plug-in or host to implement the API. Most include files define a set of independant 'suites' which are used by a plug-in to communicate with a host applications. 
      </para>
      
      <para>
	There are two include files that are used with nearly every derived API. These are...
	<itemizedlist>
	  <listitem><filename class="headerfile">ofxCore.h</filename> is used to define the basic communication mechanisms between a host and a plug-in. This includes the way in which a plug-in is defined to a host and how a plug-in and how to boostrap the two way comminications. It also has several other basic action and property definitions.
	  </listitem>
	  <listitem><filename class="headerfile">ofxProperty.h</filename> specifies the property suite, which is how a plug-in gets and sets values on various objects in a host application.
	  </listitem>
	</itemizedlist>
      </para>
    </section>

    <section><title>Identifying and Loading Plug-ins</title>
      <para>Plug-ins must implement two exported functions for a host to identify the plug-ins and to initiate the who boot strapping of communication between the two. These functions are...
	<itemizedlist>
	  <listitem><code>int OfxGetNumberOfPlugins(void)</code> - identifies how many plug-ins are implemented in the file,</listitem>
	  <listitem><code>OfxPlugin *OfxGetPlugin(int N)</code> - returns a structure identifying the Nth plug-in in the file.</listitem>
	</itemizedlist>
      </para>
      
      <section id="OfxGetNumberOfPlugins"><title>OfxGetNumberOfPlugins</title>
	<programlisting>
#include "ofxCore.h"
OfxExport int OfxGetNumberOfPlugins(void); </programlisting>
	<para>This function returns the number of
	  plug-ins contained in the binary. It is the very first function called
	  by the host after the binary has been loaded.</para>
	
	<para>This function <emphasis>must</emphasis> be exported by the
	  binary that contains OFX plug-ins. The
	  <structname>OfxExport</structname> defined in
	  <filename class="headerfile">ofxCore.h</filename> is used as an export declaration for
	  those compilers that require it.</para>
      </section>
      
      <section id="OfxGetPlugin"><title>OfxGetPlugin</title>
	<programlisting>
#include "ofxCore.h"
OfxExport OfxPlugin *OfxGetPlugin(int nth); </programlisting>
	
        <para>This function returns a pointer to the <varname>nth</varname>
	  <structname>OfxPlugin</structname> struct in the binary.
	  <varname>nth</varname> is between 0 and the number returned by
	  <function>OfxGetNumberOfPlugins</function>. The returned structure
	  defines the plug-in to the host.</para>
	
        &preconditions;
        <para>
          <itemizedlist>
            <listitem> <function>OfxGetNumberOfPlugins</function> has been previously called, </listitem>
            <listitem> <varname>nth</varname> is between 0 and the value returned by <function>OfxGetNumberOfPlugins</function>.
            </listitem>
          </itemizedlist>
        </para>
	
        &postconditions;
        <para>
          <itemizedlist>
            <listitem> The returned pointer and pointers in the struct point to valid data whilst the binary is loaded, </listitem>
            <listitem> The returned pointer and pointers in the struct do not need to be freed in any way by the host. </listitem>
          </itemizedlist>
        </para>
      </section>
      &ofxPluginStruct;
    </section>
        
    &ofxHostStruct;
    
    <section id="mainEntryPoint"><title>The Plug-in Main Entry Point And Actions</title>
      <para>Actions are how a host communicates with a plug-in. They are in effect generic function calls. Actions are issued via a plug-in's <function>mainEntry</function> function pointer found in its <code>OfxPlugin</code> struct. The function signature for the main entry point is...  </para>
      <programlisting>
#include "ofxCore.h"
typedef  OfxStatus (OfxPluginEntryPoint)(const char *action, const void *handle, OfxPropertySetHandle inArgs, OfxPropertySetHandle outArgs); </programlisting>
      <para> Where,
	<itemizedlist>
	  <listitem><code>action</code> is a C string indicating the action to be taken,</listitem>
	  <listitem><code>handle</code> is a handle to an object appropriate to that action, cast to <code>void *</code>,</listitem>
	  <listitem><code>inArgs</code> are a set of properties used as arguments to that action,</listitem>
	  <listitem><code>outArgs</code> are a set of properties the plug-in should modify during the action.</listitem>
	</itemizedlist>
      </para>
      <para>
	The <code>OfxStatus</code> value returned is dependant upon the action being called, however the value <code>kOfxStatReplyDefault</code> is returned if the plug-in does not trap the action.
      </para>
      <para>The exact set of actions passed to a plug-in's entry point are dependent upon the API the plug-in implements. However, there exists a core set of generic actions that most APIs would use.</para>
    </section>
    
    <section><title>Suites</title>
      <para>Suites are how a plug-in communicates back to the host. A suite is simply a set of function pointers in a C struct. The set of suites a host needs to implement is defined by the API being implemented. A suite is fetched from a host via the <code>OfxHost::fetchSuite</code> function. This returns a pointer (cast to <code>void *</code>) to the named and versioned set of functions. By using this suite fetching mechanism, there is no symbolic dependancy from the plug-in to the host, and APIs can be easily expandable without causing backwards compatability issues.
      </para>
      <para>If the host does not implement a requested suite, or the requested version of that suite, then it should return NULL.
      </para>
    </section>
    
    &ofxLoadingSequence;

    
    <section><title>Who Owns The Data?</title>
      <para>
	Objects are passed back and forth across the API, and in general, it is the thing that passes the data that is
	responsible for destroying it. For example the property set handle in the <link linkend="OfxHostStruct"><code>OfxHost struct</code></link>
	is managed by the host.
      </para>

      <para>
	There are a few explicit exceptions to this. For example, when an image effect asks for an image from a host
	it is passed back a property set handle which represents the image. That handle needs to later be desposed of
	by an effect by an explicit function call back to the host. These few exceptions are documented with the suite
	functions that access the object.
      </para>

      <section><title>Strings</title>
	<para>
	  A special case is made for strings. Strings are considered to be of two types, <emphasis>value</emphasis> strings and 
	  <emphasis>label</emphasis> strings. 
	  A label string is any string used by OFX to name a property or type. A value string is generally a string value of a property.
	</para>

	<para>
	  More specifically, a label string is a string passed across the API as one of the following...
	  <itemizedlist>
	    <listitem> a property label (ie: the 'char *property' argument in the property suites)</listitem>
	    <listitem> a string argument to a suite function which must be one of a set of predefined set of values
	      eg: <code>paramType</code> argument to <link linkend="OfxParameterSuiteV1_paramDefine">OfxParameterSuiteV1::paramDefine</link>, 
	      but not the <code>name</code> argument)</listitem>
	  </itemizedlist>
	</para>
	
	<para>
	  Label strings are considerred to be static constant strings, when passed across the API the host/plug-in recieving the string neither needs to duplicate or free the string, it can simply retain the orginal pointer passed over and use that in future, as it will not change. A host must be aware that when it unloads a plug-in all such pointers will be invalid, and be prepared to cope with such a situation.
	</para>
	
	<para>
	  A value string is a string passed across the API as one of the following...
	  <itemizedlist>
	    <listitem>all value arguments to any of the property suite calls,</listitem>
	    <listitem>any other <code>char *</code> argument to any other function.</listitem>
	  </itemizedlist>
	</para>

	<para>
	  Value strings have no assumptions made about them, when one is passed across the
	  API, the thing that passed the string retains ownership of it. The thing getting the 
	  string is not responsible for freeing that string. The scope of the string's validity
	  is until the next OFX API function is called. For example, within a plugin
	</para>

	<programlisting>
   // pointer to store the returned value of the host name
   char *returnedHostName;

   // get the host name
   propSuite->propGetString(hostHandle, kOfxPropName, 0, &amp;returnedHostName);

   // now make a copy of that before the next API call, as it may not be valid after it
   char *hostName = strdup(returnedHostName);

   paramSuite->getParamValue(instance, "myParam", &amp;value);
	</programlisting>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>The Image Effect API</title>
    
    <section> <title>Introduction</title>
      <para>
	In general, image effects plug-ins take zero or more input clips and produce an output clip.
	So far so simple, however there are many devils hiding in the details. Several supporting suites 
	are required from the host and the plug-in needs to respond to a range of actions to work correctly. 
	How an effect is intended to be used also complicates the issue, forcing sets of behaviours depending on the context of an effect.
      </para>

      <para>
	Plug-Ins that implement the image effect API set the <code>pluginApi</code> member of the <code>OfxPlugin struct</code> 
	returned by the global <code>OfxGetPlugin</code> to be <literal>kOfxImageEffectPluginApi</literal>.
	The current version of the API is 1. This is enough to label the plug-in as an image effect plug-in.
      </para>
    </section>

    <section><title>Image Effect API Header Files</title>
      <para>
	The header files used to define the OFX Image Effect API are...
	<itemizedlist>
	  <listitem>
	    <filename class="headerfile">ofxCore.h</filename>
	    - provides the core definitions of the general OFX architecture that allow the bootstrapping of specific APIs, as well as several core actions,
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxProperty.h</filename>
	    - provides generic property fetching suite used to get and set values about objects in the API, 
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxParam.h</filename>
	    - provides the suite for defining user visible parameters to an effect, 
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxMultiThread.h</filename>
	    - provides the suite for basic multi-threading capabilities, 
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxInteract.h</filename>
	    - provides the suite that allows a plug-in to use OpenGL to draw their own interactive GUI tools, 
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxKeySyms.h</filename>
	    - key symbols used by 'Interacts' to represent keyboard events, 
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxMemory.h</filename>
	    - provides a simple memory allocation suite, 
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxMessage.h</filename>
	    - a simple messaging suite to communicate with an end user, 
	  </listitem>
	  <listitem>
	    <filename class="headerfile">ofxImageEffect.h</filename>
	    - defines a suite and set of actions that draws all the above together to create an visual effect plug-in. 
	  </listitem>
	</itemizedlist>
	These contain the suite definitions, property definitions and action definitions that are used by the API.
      </para>
    </section>

    <section>
      <title>Actions Used by the API</title>
      <para>
	All image effect plug-ins have a main entry point. This is used to trap all the standard actions used to drive the plug-in. They can also have other optional
	entry points that allow the plug-in to create custom user interface widgets. These <emphasis>interact</emphasis> entry points are specified during the 
	two description actions.
      </para>
      
      <para>
	The following actions can be passed to a plug-in's main entry point...
	<itemizedlist>
	  <listitem>
	    <link linkend="kOfxActionLoad">The Generic Load Action</link> called just after a plug-in is first loaded,
	    </listitem>
	  <listitem>
	    <link linkend="kOfxActionUnload">The Generic Unload Action</link> called just before a plug-in is unloaded,
	  </listitem>
      	  <listitem>
	    <link linkend="kOfxActionDescribe">The Generic Describe Action</link> called to described a plug-in's behaviour to a host,
	    </listitem>
	  <listitem>
	    <link linkend="kOfxActionCreateInstance">The Generic Create Instance Action</link> called just after an instance is created,
	    </listitem>
	  <listitem>
	    <link linkend="kOfxActionDestroyInstance">The Generic Destroy Instance Action</link> called just before an instance is destroyed,
	    </listitem>
	  <listitem>
	    <link linkend="kOfxActionBeginInstanceChanged">The Generic Begin/End Instance Changed Actions</link> a pair of actions used to bracket a set Instance Changed actions,
	    </listitem>
	  <listitem>
	    <link linkend="kOfxActionInstanceChanged">The Generic Instance Changed Action</link> an action used to indicate that a value has changed in a plug-in instance,
	    </listitem>

	  <listitem>
	    <link linkend="kOfxActionPurgeCaches">The Generic Purge Caches Action></link> called to have the plug-in delete any temporary private data caches it may have,
	    </listitem>

	  <listitem>
	    <link linkend="kOfxActionSyncPrivateData">The Sync Private Data Action</link> called to have the plug-in sync any private state data back to its data set,
	    </listitem>

	  <listitem>
	    <link linkend="kOfxActionBeginInstanceEdit">The Generic Begin/End Instance Edit Actions</link> a pair of calls that are used to bracket the fact that a user interface has been opened on an instance and it is being edited,
	    </listitem>

	  <listitem>
	    <link linkend="kOfxImageEffectActionBeginSequenceRender">The Begin Sequence Render Action</link> where a plug-in is told that it is about to render a sequence of images,
	  </listitem>
	  
	  <listitem>
	    <link linkend="kOfxImageEffectActionRender">The Render Action</link> where a plug-in is told that it is to render an output image,
	  </listitem>
	  
	  <listitem>
	    <link linkend="kOfxImageEffectActionEndSequenceRender">The End Sequence Render Action</link> where a plug-in is told it has finished rendering a sequence of images,
	  </listitem>
	  <listitem>
	    <link linkend="kOfxImageEffectActionDescribeInContext">The Describe In Context Action</link> used to have a plug-in describe itself in a specific context,
	    </listitem>

	  <listitem>
	    <link linkend="kOfxImageEffectActionGetRegionOfDefinition">The Get Region of Definition Action</link> where an instance gets to state how big an image it can create,
	  </listitem>
	  
	  <listitem>
	    <link linkend="kOfxImageEffectActionGetRegionsOfInterest">The Get Regions Of Interest Action</link> where an instance gets to state how much of its input images it needs to create a give output image,
	  </listitem>
	  
	  <listitem>
	    <link linkend="kOfxImageEffectActionGetFramesNeeded">The Get Frames Needed Action</link> where an instance gets to state how many frames of input it needs on a given clip to generate a single frame of output,
	  </listitem>
	  
	  <listitem>
	    <link linkend="kOfxImageEffectActionIsIdentity">The Is Identity Action</link> where an instance gets to state that its current state does not affect its inputs, so that the output can be directly copied from an input clip,
	  </listitem>
	  
	  <listitem>
	    <link linkend="kOfxImageEffectActionGetClipPreferences">The Get Clip Preferences Action</link> where an instance gets to state what data and pixel types it wants on its inputs and will generate on its outputs,
	  </listitem>
	  
	  <listitem>
	    <link linkend="kOfxImageEffectActionGetTimeDomain">The Get Time Domain Action</link> where a plug-in gets to state how many frames of data it can generate.
	  </listitem>
	</itemizedlist>
      </para>

      <para>	
	The following actions are passed to any interact entry point in an image effect plug-in.
	<itemizedlist>
      	  <listitem>
	    <link linkend="kOfxActionDescribeInteract">The Generic Describe Action</link> called to describe the specific <emphasis>interact</emphasis>,
	  </listitem>
	  <listitem>
	    <link linkend="kOfxActionCreateInstanceInteract">The Create Instance Action</link> called just after an instance of the <emphasis>interact</emphasis> is created,
	  </listitem>
	  <listitem>
	    <link linkend="kOfxActionDestroyInstanceInteract">The Generic Destroy Instance Action</link> called just before of the <emphasis>interact</emphasis> is destroyed,
	    </listitem>
	  <listitem>
	    <link id="kOfxInteractActionDraw">The Draw Action</link> called to have the interact draw itself,
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionPenMotion">kOfxInteractActionPenMotion</link> called whenever the interact has the input focus and the pen has moved,
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionPenDown">kOfxInteractActionPenDown</link> called whenever the interact has the input focus and the pen has changed state to 'down',
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionPenUp"> kOfxInteractActionPenUp</link> called whenever the interact has the input focus and the pen has changed state to 'up,
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionKeyDown"> kOfxInteractActionKeyDown</link> called whenever the interact has the input focus and a key has gone down,
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionKeyUp"> kOfxInteractActionKeyUp</link> called whenever the interact has the input focus and a key has gone up,
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionKeyRepeat"> kOfxInteractActionKeyRepeat</link> called whenever the interact has the input focus and a key has gone down and a repeat key sequence has been sent,
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionGainFocus"> kOfxInteractActionGainFocus</link> called whenever the interact gains input focus,
	  </listitem>
	  <listitem>
	    <link id="kOfxInteractActionLoseFocus"> kOfxInteractActionLoseFocus</link> called whenever the interact loses input focus,
	  </listitem>
	</itemizedlist>
	    
      </para>
    </section>

    <section><title>Main Objects Used by the API</title>
      <para>
	The image effect API uses a variety of different objects. Some defined via blind data handles, other via property sets, or a combination of the two. These objects are...
	<itemizedlist>
	  <listitem>
	    <emphasis>Host Descriptor</emphasis> - a descriptor object used by a host to describe its behaviour to a plug-in,
	  </listitem>
	  <listitem>
	    <emphasis>Image Effect Descriptor</emphasis> - a descriptor object used by a plug-in to describe its behaviour to a host,
	  </listitem>
	  <listitem>
	    <emphasis>Image Effect Instance</emphasis> - an instance object maintaining state about an image effect,
	  </listitem>
	  <listitem>
	    <emphasis>Clip Descriptor</emphasis> - a descriptor object for a sequence of images used as input or output a plug-in may use,
	  </listitem>
	  <listitem>
	    <emphasis>Clip Instance</emphasis> - a instance object maintaining state about a sequence of images used as input or output to an effect instance,
	  </listitem>
	  <listitem>
	    <emphasis>Parameter Descriptor</emphasis> - a descriptor object used to specify a user visible parameter in an effect descriptor,
	  </listitem>
	  <listitem>
	    <emphasis>Parameter Instance</emphasis> - an instance object that maintains state about a user visible parameter in an effect instance,
	  </listitem>
	  <listitem>
	    <emphasis>Parameter Set Descriptor</emphasis> - a descriptor object used to specify a set of user visible parameters in an effect descriptor,
	  </listitem>
	  <listitem>
	    <emphasis>Parameter Set Instance</emphasis> - an instance object that maintains state about a set of user visible parameter in an effect instance,
	  </listitem>
	  <listitem>
	    <emphasis>Image Instance</emphasis> - a instance object that maintains state about a 2D image being passed to an effect instance.
	  </listitem>
	  <listitem>
	    <emphasis>Interact Descriptor</emphasis> - which describes a custom openGL user interface, for example an overlay over the inputs to an image effect. These have
	    a separate entry point to an image effect.
	  </listitem>
	  <listitem>
	    <emphasis>Interact Instance</emphasis> - which holds the state on a custom openGL user interface. These have a separate entry point to an image effect.
	  </listitem>
	</itemizedlist>
      </para>
      
      <section> <title>Host Descriptors</title>
	<para>
	  The host descriptor is represented by the properties found on the <code>host</code> property set handle 
	  in the <link linkend="OfxHostStruct"><code>OfxHost struct</code></link>. The complete set of read only
	  properties are found in the section <link linkend="ImageEffectHostProperties">Properties on the Image Effect Host</link>.
	</para>
	
	<para>
	  These set of properties are there to describe the capabilities of the host to a plug-in, thus giving a plug-in the ability to modify
	  its behaviour depending on the capabilities of the host. 
	</para>
	
	<para>
	  A host descriptor is valid while a plug-in is loaded.
	</para>
      </section>
      
      <section> <title>Effects</title>
	<para>
	  An effect is an object in the OFX Image Effect API that represents an image processing plug-in. It has associated with it associated with it
	  a set of properties, a set of image clips and a set of properties. These component objects of an effect are defined and used by an effect
	  to do whatever processing it needs to. A handle to an image effect (instance or descriptor) is passed into a plug-ins  
	  <link linkend="mainEntryPoint">main entry point</link> <code>handle</code> argument. 
	</para>
	
	<para>
	  The functions that directly manipulate an image effect handle are specified in the <link linkend="OfxImageEffectSuiteV1">image effect suite</link>
	  found in the header file <filename class="headerfile">ofxImageEffect.h</filename>. 
	</para>
	
	<section> <title>Effect Descriptors</title>
	  <para>
	    An effect descriptor is an object of type <code>OfxImageEffectHandle</code> passed into an effect's <link linkend="mainEntryPoint">main 
	      entry point</link> <code>handle</code> argument. The two actions
	    it is passed to are...
	    <itemizedlist>
	      <listitem><link linkEnd="kOfxActionDescribe">kOfxActionDescribe</link></listitem>
	      <listitem><link linkEnd="kOfxImageEffectActionDescribeInContext">kOfxActionDescribe</link></listitem>
	    </itemizedlist>
	  </para>
	  
	  <para>
	    A effect descriptor does not refer to a 'live' effect, it is a handle which the effect uses to describe itself back to the host. It does
	    this by setting a variety of properties on an associated property handle, and specifying a variety of objects (such as clips and parameters) using
	    functions in the available suites.
	  </para>
	  
	  <para>
	    Once described, a host should cache away the description in some manner so that when an instance is made, it simply looks at the description
	    and creates the necessary objects needed by that instance. This stops the overhead of having every instance be forced to describe itself over
	    the API.
	  </para>
	  
	  <para>
	    Effect descriptors are only valid in a effect for the duration of the instance they were passed into.2
	  </para>
	  
	  <para>
	    The properties on an effect descriptor can be found in the section <link linkend="EffectDescriptorProperties">Properties on an Effect Descriptor</link>.
	  </para>
	</section>
	
	<section> <title>Effect Instances</title>
	  <para>
	    A effect instance is an object of type <code>OfxImageEffectHandle</code> passed into an effect's 
	    <link linkend="mainEntryPoint">main entry point</link> <code>handle</code> argument. The <code>handle</code> 
	    argument should be statically cast to this type. It is passed into all actions of an image effect that a
	    descriptor is not passed into.
	  </para>
	  
	  <para>
	    The effect instance represents a 'live' instance of an effect. Because an effect has previously been described, via a effect descriptor, 
	    an instance does not have to respecify the parameters, clips and properties that it needs. These means, that when an instance is passed 
	    to an effect, all the objects previously described will have been created.
	  </para>
	  
	  <para>
	    Generally multiple instances of an effect can be in existance at the same time, each with a different set of parameters, clips and properties.
	  </para>
	  
	  <para>
	    Effect instances are valid between the calls to <link linkend="kOfxActionCreateInstance">kOfxActionCreateInstance</link> and
	    <link linkend="kOfxActionDestroyInstance">kOfxActionDestroyInstance</link>, for which it is passed as the <code>handle</code> argument.
	  </para>
	  
	  <para>
	    The properties on an effect instance can be found in the section <link linkend="EffectInstanceProperties">Properties on an Effect Instance</link>.
	  </para>
	</section>
      </section>
      
      <section> <title>Clips</title>
	<para>
	  A clip is a sequential set of images attached to an effect. They are used to fetch images from a host and to specify how a plug-in wishes
	  to manage the sequence.
	</para>
	
	<section> <title>Clip Descriptors</title>
	  <para>
	    Clip descriptors are returned by the <link linkend="OfxImageEffectSuiteV1_clipDefine"><code>OfxImageEffectSuiteV1::clipDefine</code></link>
	    function. They are used during the <link linkEnd="kOfxImageEffectActionDescribeInContext">kOfxActionDescribe</link> action by an effect
	    to indicate the presence of an input or output clip and how that clip behaves.
	  </para>
	  
	  <para>
	    A clip descriptor is only valid for the duration of the action it was created in.
	  </para>
	  
	  <para>
	    The properties on a clip descriptor can be found in the section <link linkend="ClipDescriptorProperties">Properties on a Clip Descriptor</link>.
	  </para>
	</section>
	
	<section> <title>Clip Instances</title>
	  <para>
	    Clip instances are returned by the <link linkend="OfxImageEffectSuiteV1_clipGetHandle"><code>OfxImageEffectSuiteV1::clipGetHandle</code></link>
	    function. They are are used to access images and and manipulate properties on an effect instance's input and output clips. A variety of functions
	    in the <link linkend="OfxImageEffectSuiteV1"><code>OfxImageEffectSuiteV1</code></link> are used to manipulate them.
	  </para>
	  
	  <para>
	    A clip instance is valid while the related effect instance is valid.
	  </para>
	  
	  <para>
	    The properties on a clip instance can be found in the section <link linkend="ClipInstanceProperties">Properties on a Clip Instance</link>.
	  </para>
	</section>
      </section>
      
      <section> <title>Parameters</title>
	<para>
	  Parameters are user visible objects that an effect uses to specify its state. For example a floating point values used to control the
	  blur size in a blur effect. Parameters (both descriptors and instances) are represented as blind data handles of type <code>OfxParamHandle</code>
	</para>
	
	<para>
	  Parameter sets the collection of parameters that an effect has associated with it. They are represented by the type <code>OfxParamSetHandle</code>.
	  The contents of an effect's parameter set are defined during the 
	  <link linkend="kOfxImageEffectActionDescribeInContext"><code>kOfxImageEffectActionDescribeInContext</code></link> action. Parameters cannot be
	  dynamically added to, or deleted from an effect instance.
	</para>
	
	<para>
	  Parameters can be of a wide range of types, each of which have their own unique capabilities and property sets. For example a colour parameter
	  differs from a boolean parameter.
	</para>
	
	<para>
	  Parameters and parameter sets are manipulated via the calls and properties in the <link linkend="OfxParameterSuiteV1">parameter suite</link>
	  specified in <filename class="headerfile">ofxParam.h</filename> header file. The properties on parameter instances and descriptors can
	  be found in the section <link linkend="ParameterProperties">Properties on Parameter Descriptors and Instances</link>.
	</para>
	
	<section> <title>Parameter Set Descriptors</title>
	  <para>
	    Parameter set descriptors are returned by the <link linkend="OfxImageEffectSuiteV1_getParamSet"><code>OfxImageEffectSuiteV1::getParamSet</code></link>
	    function. This returns a handle associated with an image effect descriptor which can be used by the parameter suite routines to create and describe
	    parameters to a host.
	  </para>
	  
	  <para>
	    A parameter set descriptor is valid for the duration of the 
	    <link linkend="kOfxImageEffectActionDescribeInContext"><code>kOfxImageEffectActionDescribeInContext</code></link> 
	    action in which it is fetched.
	  </para>
	</section>
	
	<section> <title>Parameter Descriptors</title>
	  <para>
	    Parameter descriptors are returned by the <link linkend="OfxParameterSuiteV1_paramDefine"><code>OfxParameterSuiteV1::paramDefine</code></link>
	    function. They are are used to define the existance of a parameter to the host, and to set the various attributes of that parameter. Later,
	    when an effect instance is created, an instance of the described parameter will also be created.
	  </para>
	  
	  <para>
	    A parameter descriptor is valid for the duration of the 
	    <link linkend="kOfxImageEffectActionDescribeInContext"><code>kOfxImageEffectActionDescribeInContext</code></link> 
	    action in which it is created.
	  </para>
	</section>
	
	<section> <title>Parameter Set Instances</title>
	  <para>
	    Parameter set instances are returned by the <link linkend="OfxImageEffectSuiteV1_getParamSet"><code>OfxImageEffectSuiteV1::getParamSet</code></link>
	    function. This returns a handle associated with an image effect instance which can be used by the parameter suite routines to fetch and describe
	    parameters to a host.
	  </para>
	  
	  <para>
	    A parameter set handle instance is valid while the associate effect instance remains valid.
	  </para>
	</section>
	
	<section> <title>Parameter Instances</title>
	  <para>
	    Parameter instances are returned by the <link linkend="OfxParameterSuiteV1_paramGetHandle"><code>OfxParameterSuiteV1::paramGetHandle</code></link>
	    function. This function fetches a previously described parameter back from the parameter set. The handle can then be passed back to the
	    various functions in the <link linkend="OfxParameterSuiteV1"><code>OfxParameterSuite1V</code></link> to manipulate it.
	  </para>
	  
	  <para>
	    A parameter instance handle remains valid while the associated effect instance remains valid.
	  </para>
	  
	</section>
	
	<section> <title>Image Instances</title>
	  <para>
	    An image instance is an object returned by the <link linkend="OfxImageEffectSuiteV1_clipGetImage"><code>OfxImageEffectSuiteV1::clipGetImage</code></link>
	    function. This fetches and image out of a clip and returns it as a property set to the plugin. The image can be accessed by looking up the property
	    values in that set, which includes the data pointer to the image.
	  </para>
	  
	  <para>
	    An image instance is valid until the effect calls
	    <link linkend="OfxImageEffectSuiteV1_clipReleaseImage"><code>OfxImageEffectSuiteV1::clipReleaseImage</code></link> on the property handle. The effect
	    <emphasis>must</emphasis> release all fetched images before it returns from the action.
	  </para>

	  <para>
	    The set of properties that make up an image can be found in the section 
	    <link linkend="ImageProperties_clipReleaseImage">Properties on an Image</link>.
	  </para>
	  
	</section>
      </section>
      
      <section> <title>Interacts</title>
	<para>
	  An interact is an OFX object that is used to draw custom user interface elements, for example overlays ontop of a host's image viewer
	  or custom parameter widgets. Interacts have their own <link linkend="mainEntryPoint">main entry point</link>, which is separate to the
	  effect's main entry point. Typically an interact's main entry point is specified as a pointer property on an OFX object, for example
	  the <link linkend="kOfxImageEffectPluginPropOverlayInteractV1"><code>kOfxImageEffectPluginPropOverlayInteractV1</code></link>
	  property on an effect descriptor.
	</para>
	
	<para>
	  The functions that directly manipulate interacts in the <link linkend="OfxInteractSuiteV1">interact suite</link>
	  found in the header file <filename class="headerfile">ofxInteract.h</filename>. As well as the properties and
	  specific actions that apply to interacts.
	</para>
	
	<section> <title>Interact Descriptors</title>
	  <para>
	    Interact descriptors are blind handles passed to the <link linkend="kOfxActionDescribeInteract">describe action</link> sent to 
	    an interact's separate main entry point. They should be case to the type <code>OfxInteractHandle</code>.
	  </para>
	  
	  <para>
	    The properties found on a descriptor are found in section <link linkend="InteractDescriptorProperties">Properties on Interact Descriptors</link>.
	  </para>
	  
	</section>
	
	<section> <title>Interact Instances</title>
	  <para>
	    Interact instances are blind handles passed to all actions but the <link linkend="kOfxActionDescribeInteract">describe action</link> sent to 
	    an interact's separate main entry point. They should be case to the type <code>OfxInteractHandle</code>.
	  </para>
	  
	  <para>
	    The properties found on an instance are found in section <link linkend="InteractInstanceProperties">Properties on Interact Instance</link>.
	  </para>
	</section>
      </section>
    </section>
  </chapter>


  <chapter><title>Image Processing Architectures</title>
    <para>
      OFX supports a range of image processing architectures. The simpler ones being special cases of
      the most complex one. Levels of support, in both plug-in and host, are signalled by setting appropriate
      properties in the plugin and host.
    </para>

    <para>
      This chapter describes the most general architecture that OFX can support, with simpler cases just being specialisations
      of the general case.      
    </para>

    <section><title>The Image Plane</title>
      <para>
	At it's most generalised, OFX allows for a complex imaging architecture based around an infinite 2D plane on which we are filling in pixels.
      </para>

      <para>
	Firstly, there is some subsection of this infinite plane that the user wants to be the end result of their work, call this the project extent. 
	The project extent is always rooted, on its bottom left, at the origin of the image plane. The project extent defines the upper right hand corner 
	of the project window. For example a PAL sized project spans (0, 0) to (768, 576) on the image plane. 
      </para>

      <para>
	We define an image effect as something that can fill in a rectangle of pixels in this infinite plane, possibly using images defined at other locations
	on this image plane.
      </para>

    </section>

    <section><title>Regions of Definition</title>
    
      <para>
	An effect has a "Region of Definition" (RoD), this is is the maximum area of the plane that the effect can fill in. 
	for example: a 'read source media' effect would only be able to fill an area as big as it's source media. An effect's 
	RoD may need to be based on the RoD of its inputs, for example: the RoD of a contrast/brightness colour corrector would 
	generally be the RoD of it's input, while the RoD of a rotation effect would be bigger than that of it's input image.
      </para>

      <para>
	The purpose of the <link linkend="kOfxImageEffectActionGetRegionOfDefinition"><code>kOfxImageEffectActionGetRegionOfDefinition</code></link>
	action is for the host to ask an effect what its region of definition is. An effect calculates this by looking at its input clips and the
	values of its current parameters.
      </para>

      <para>
	Hosts are not obliged to render all an effects RoD, as it may have fixed frame sizes, or any number of other issues.
      </para>

      <para>
	Infinite RoDs are valid, eg: a no-input noise generator could generate random colours anywhere it was asked to.
	An infinite RoD is flagged by setting the minimums to be ::kOfxFlagInfiniteMin and the maxmimums to be ::kOfxFlagInfiniteMax,
	for both double and integer rects.
      </para>

      <para>
	PICTURES
      </para>
    </section>

    <section><title>Regions Of Interest</title>
      <para>
	An effect will be asked to fill in some region of this infinite plane. The section it is being asked
	to fill in is called the "Region of Interest" (RoI). 
      </para>
	
      <para>
	Before an effect has been asked to process a given RoI, it will be asked to specify the area of each input clip 
	it will need to process that area. For example: a simple colour correction effect only needs as much input as it
	does output, while a blur will need an area that is larger than the specified RoI by a border of the same width
	as the blur radius.
      </para>

      <para>
	The purpose of the <link linkend="kOfxImageEffectActionGetRegionOfInterest"><code>kOfxImageEffectActionGetRegionOfInterest</code></link>
	action is for the host to ask an effect what areas it needs from each input clip, to render a specific output region. An effect needs
	to examine its set of parameters and the region it has been asked to render to determine how much of <emphasis>each</emphasis> input
	clip it needs.
      </para>
      <para>
	PICTURES
      </para>
    </section>

    <section><title>Tree Based Architectures</title>
      <para>
	The most general compositing hosts allow images to be of any size at any location on our image plane. They also plumb the output
	of effects into other effects, to create effect trees.
	When evaluating this tree of effects, a general host will want to render the minimum number of pixels it needs to fill in the
	final desired image. Typically the top level of this compositing tree is being rendered at a certain project size, for example 
	PAL SD, 2K film and so on. This is where the RoD/RoI calls come in handy.
      </para>

      <para>
	The host asks the top effect how much picture information it can produce, which in turn asks
	effects below it their RoDs and so on until leaf effects are reached, which report back up the tree 
	until the top effect calculates its RoD and reports back to the host. The host typically clips that
	RoD to its project size.
      </para>

      <para>
	Having determined in this way the window it wants rendered at the top effect, the host asks the top
	node the regions of interest on each of it's inputs. This again propagates down the effect tree
	until leaf nodes are encountered. These regions of interest are cached at effect for later use.
      </para>

      <para>
	At this point the host can start rendering, from the bottom of the tree upwards, by asking each
	effect to fill in the region of interest that was previously specified in the RoI walk. These regions
	are then passed to the next level up to render and so on.
      </para>

      <para>
	Another complication is tiling. Some hosts, having determined the area that needs filling at the top
	most effect, may decide to render this in several chunks. It may do this for a variety of reasons, 
	attempting to minimise memory access or to speed up rendering by farming different sections of the 
	image to different CPUS (or even different computers). In this case, each tile needs to have it's RoIs
	calculated individually, in a similar manner as described above.
      </para>

      <para>
	The details may differ on specific hosts, but this is more or less the most generic way compositing hosts
	currently work.
      </para>

      <para>
	PICTURES
      </para>
    </section>

    <section><title>Simpler Architectures</title>
      <para>
	The above architecture is quite complex, as the inputs supplied can lie anywhere on the image plane,
	as can the output, and they can be subsections of the 'complete' image. Not all hosts work in this way,
	generally it is only the more advance compositing systems working on large resolution images. 
      </para>
      
      <para>
	Some other systems allow for images to be anywhere on the image plane, but always pass around full RoD images, 
	never tiles.
      </para>

      <para>
	The simplest systems, don't have any of of the above complexity. The RoDs, RoIs, images and project sizes in such 
	systems are exactly the same, always. Often these are editting, as opposed to compositing, systems.
      </para>

      <para>
	Similarly, some plugin effects cannot handle sub RoD images, or even images not rooted at the origin.
      </para>

      <para>
	The OFX architecture is meant to support all of them. Assuming a plugin supports the most general architecture,
	it will trivially run on hosts with simpler architectures. However, if a plugin does not support tiled, or 
	arbitarily positioned images, they may not run cleanly on hosts that expect them to do so.
      </para>

      <para>
	To this end, two properties are provided that flag the capabilities of a plugin or host...
	<itemizedlist>
	  <listitem><link linkend="kOfxImageEffectPropSupportsMultiResolution"><code>kOfxImageEffectPropSupportsMultiResolution</code></link> - which indicates support for images of differing sizes not centred on the origin,</listitem>
	  <listitem><link linkend="kOfxImageEffectPropSupportsTiles"><code>kOfxImageEffectPropSupportsTiles</code></link>- which indicates support for images that contain less than full frame pixel data</listitem>
	  </itemizedlist>
      </para>
      
      <para>
	A plug-in should flag these appropriately, so that hosts know how to deal with the effect. A host can either choose to refuse
	to load a plugin, or, preferentially, pad images with an appropriate amount of black/transparent pixels to enable them to work.
      </para>

      <para>
	The <code>kOfxImageEffectActionGetRegionsOfInterest</code> is redundant for plugins that do not support tiled rendering, 
	as the plugin is asking that it be given the full Region of Definition of all its inputs. A host may have 
	difficulty doing this (for example with an input that is attached to an effect that can create infinite images
	such as a random noise generator), if so, it should clamp images to some a size in some manner.
      </para>

      <para>
	The RoD/RoI actions are potentially redundant on simpler hosts. For example fixed frame size hosts. If a host has no need to
	call these actions, it simply should not.
      </para>
    </section>
  </chapter>


  &clipPreferencesChapter;

  &imageEffectActionsChapter;

  <chapter id="PropertySuiteReference">
    <title>Property Suite</title>
    <para>The files <filename class="headerfile">ofxCore.h</filename> and <filename class="headerfile">ofxProperty.h</filename> contain the basic definitions for the property suite. </para>
    <para>The property suite is the most basic and important suite in OFX, it is used to get and set the values of various objects defined by other suites. 
    </para>
    <para>A property is a named value of a specific data type, such values can be multi-dimensional, but is typically of one dimension. The name 
      is a 'C' string literal, typically #defined in one of the various OFX header files. For example, the property labeled by the string literal <constant>"OfxPropName"</constant> is a 'C' string which holds the name of some object.
    </para>
    <para>Properties are not accessed in isolation, but are grouped and accessed through a property set handle. The number and types of properties on a specific property set handle are currently strictly defined by the API that the properties are being used for. There is no scope to add new properties.
    </para>
    <para>There is a naming convention for property labels and the macros #defined to them. The scheme is,
      <itemizedlist>
        <listitem>generic properties names start with <constant>"OfxProp"</constant> + name of the property, e.g. "OfxPropTime".</listitem>
        <listitem>properties pertaining to a specific object with <constant>"Ofx"</constant> + object name + <constant>"Prop"</constant> + name of the property, e.g. "OfxParamPropAnimates".</listitem>
        <listitem>the C preprocessor #define used to define the string literal is the same as the string literal, but with 
          <constant>"k"</constant> prepended to the name. For example, <constant> #define kOfxPropLabel "OfxPropLabel" </constant> </listitem>
      </itemizedlist>
      
    </para>
    
    <refentry id="OfxPropertySetHandle">
      <refmeta>
        <refentrytitle><type>OfxPropertySetHandle</type></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><type>OfxPropertySetHandle</type></refname>
	
        <refpurpose>Blind data type used to hold sets of properties</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
typedef struct OfxPropertySetStruct *OfxPropertySetHandle; </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
        <para>
	  Properties are not accessed on their own, nor do they exist on their own. They are grouped and manipulated via an OfxPropertySetHandle.</para>
        <para>Any object that has properties can be made to return it's property set handle via some call on the relevant suite. Individual properties are then manipulated with the property suite through that handle.
        </para>
      </refsect1>
    </refentry>
    
    &ofxPropertySuiteReference;
  </chapter>
  
  <chapter id="ImageEffectSuite">
    <title>Image Effect Suite</title>
    &ofxImageEffectSuiteReference;
  </chapter>
  
  <chapter id="ParametersSuite">
    <title>Parameters Suite</title>
    &ofxParametersSuiteReference;
  </chapter>
  
  <chapter id="MemorySuite">
    <title>Memory Suite</title>
    &ofxMemorySuiteReference;
  </chapter>
  
  <chapter id="MultiThreadingSuite">
    <title>Multi Threading Suite</title>
    &ofxThreadingSuiteReference;
  </chapter>
  
  <chapter id="InteractSuite">
    <title>Interact Suite</title>
    &ofxInteractSuiteReference;
  </chapter>
  
  <chapter id="describingImageEffects"><title>Describing Image Effects</title>
  </chapter>

  <chapter id="PropertiesByObject">
    <title>Properties By Object</title>
    <para>This chapter lists all the properties on each OFX object.</para>
    &propertiesByObject; 
  </chapter>
  
  <chapter id="PropertiesByName">
    <title>Property By Name</title>
    &propertiesReference; 
  </chapter>
  
  <chapter>
    <title>Status Codes</title>
    
    <para>Status codes are returned by most functions in OFX suites and all
      plug-in actions to indicate the sucess or failure of the operation. All
      status codes are defined in <filename class="headerfile">ofxCore.h</filename> and
      <code>#defined</code> to be integers.</para>
    
    <refentry id="OfxStatus">
      <refmeta>
        <refentrytitle><type>OfxStatus</type></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><type>OfxStatus</type></refname>
	
        <refpurpose>type returned to indicate success or failure of an
	  operation.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
typedef int OfxStatus; </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>Most OFX functions in host suites and all actions in a plug-in
	  return a status code, where the status codes are all 32 bit integers.
	  This typedef is used to label that status code.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatOK">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatOK</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatOK</errorcode></refname>
	
        <refpurpose>(0), indicates an operation completed
	  sucessfully.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatOK 0 </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This error code is returned by <itemizedlist>
            <listitem>
	      host functions to indicate success of the operation, 
            </listitem>
	    
            <listitem>
	      plug-in actions to indicate that the action was trapped and suceeded. 
            </listitem>
          </itemizedlist></para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatFailed">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatFailed</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatFailed</errorcode></refname>
	
        <refpurpose>(1), indicates a failed operation.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatFailed  ((int)1) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This error code is returned when a function or action could not
	  complete normally and its operation failed.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrFatal">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrFatal</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrFatal</errorcode></refname>
	
        <refpurpose>(2), indicates a fatal operation.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrFatal  ((int)2) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This status is only returned in the case where the plug-in or
	  host has encountered an error that is likely to be fatal to continued programme execution.
        </para>
        <para>If a plug-in returns this, a host may attempt to continue.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrUnknown">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrUnknown</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrUnknown</errorcode></refname>
	
        <refpurpose>(3), status error code for an unknown object.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrUnknown ((int)3) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This error is returned when an operation is attempted on an
	  unknown object or an unknown object was requested. For example, a host
	  may not support a property on an object because it is written to a
	  slightly earlier version of an API, in which case it should return
	  with <errorcode>kOfxStatErrUnknown</errorcode>.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrMissingHostFeature">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrMissingHostFeature</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrMissingHostFeature</errorcode></refname>
	
        <refpurpose>(4) returned by a plug-in if a host is
	  inadequate.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrMissingHostFeature ((int) 4) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This status is returned by plug-ins'
	  <function>mainEntry</function> if the host is missing a feature they
	  need to operate. For example, a plug-in may need an overlay GUI to
	  operate sucessfully, which is an optional feature.</para>
	
        <para>This should be returned from the
	  <literal>kOfxActionLoad</literal>,
	  <literal>kOfxActionDescribe</literal> or
	  <literal>kOfxImageEffectActionDescribeInContext</literal> actions, so
	  a host can unload the plug-in before it attempts to create an instance
	  of the plug-in.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrUnsupported">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrUnsupported</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrUnsupported</errorcode></refname>
	
        <refpurpose>(5), error code for an unsupported
	  feature/operation</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrUnsupported ((int) 5) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This is returned by suite functions to indicate an operation is
	  unsupported. For example, a plug-in may attempt to use a custom
	  parameter GUI on a host that does not support it, in which case the
	  host should return <errorcode>kOfxStatErrUnsupported</errorcode> when
	  the plug-in does so.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrExists">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrExists</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrExists</errorcode></refname>
	
        <refpurpose>(6), something already exists.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrExists  ((int) 6) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This error code is returned from a host function when a plug-in
	  attempts to create an object that already exists. For example, a
	  plug-in attempting to create two parameters with the same name, as the
	  name of a parameter is what defines it.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrFormat">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrFormat</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrFormat</errorcode></refname>
	
        <refpurpose>(7), indicates an incorrect format.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrFormat ((int) 7) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This error code is returned when a plug-in or hosts receives
	  something in the wrong format.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrMemory">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrMemory</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrMemory</errorcode></refname>
	
        <refpurpose>(8), a memory shortage was encountered.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrMemory  ((int) 8) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This is returned when a plug-in or host cannot complete its
	  operation because of a memory shortage.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrBadHandle">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrBadHandle</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrBadHandle</errorcode></refname>
	
        <refpurpose>(9), indicates a bad handle</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrBadHandle ((int) 9) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This status code is returned when a bad handle is passed to a
	  host function or a plug-in action.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrBadIndex">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrBadIndex</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatErrBadIndex</errorcode></refname>
	
        <refpurpose>(10), a property index was invalid.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrBadIndex ((int)10) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This is returned by host functions if an operation was requested
	  on an invalid dimension index.</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatErrValue">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatErrValue</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode> kOfxStatErrValue </errorcode></refname>
	
        <refpurpose>(11), an illegal value was passed.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatErrValue ((int) 11) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This error code is returned if an attempt was made to set an
	  illegal value on an object. For example if an image effect plug-in
	  attempted to set a supported pixel depth of "wibble".</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatReplyYes">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatReplyYes</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatReplyYes</errorcode></refname>
	
        <refpurpose>(12), returned to indicate a positive
	  response.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatReplyYes ((int) 12) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This is typically returned from a function involving user
	  interaction and indicates they had a positive response. e.g. the
	  messaging suite can ask the user a question to which they can reply
	  "yes" or "no".</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatReplyNo">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatReplyNo</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatReplyNo</errorcode></refname>
	
        <refpurpose>(13), returned to indicate a positive
	  response.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatReplyNo ((int) 13) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This is typically returned from a function involving user
	  interaction and indicates they had a negative response. e.g. the
	  messaging suite can ask the user a question to which they can reply
	  "yes" or "no".</para>
      </refsect1>
    </refentry>
    
    <refentry id="kOfxStatReplyDefault">
      <refmeta>
        <refentrytitle><errorcode>kOfxStatReplyDefault</errorcode></refentrytitle>
      </refmeta>
      
      <refnamediv>
        <refname><errorcode>kOfxStatReplyDefault</errorcode></refname>
	
        <refpurpose>(14), indicates the default should occur.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include "ofxCore.h"
#define kOfxStatReplyDefault ((int) 14) </programlisting>
      </refsynopsisdiv>
      
      <refsect1>
        <title>Description</title>
	
        <para>This is returned by plug-ins' <function>mainEntry</function>
	  function to indicate that they did not trap the action passed and that
	  the default operation should occur. It does not imply failure.</para>
	
        <para>A subtle but specific use of this is made by plug-in interacts
	  GUIs. If they return this value from any event actions (eg:
	  <literal>kOfxInteractActionPenDown</literal>), then the host is free
	  to pass the event on to another GUI element in the interact
	  window.</para>
      </refsect1>
    </refentry>
  </chapter>
</book>
